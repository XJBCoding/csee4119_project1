#!/usr/bin/env python
from socket import socket, AF_INET, SOCK_STREAM
import select
import time
import re
import sys
import thread
from multiprocessing import Process
class Proxy:
    def __init__(self,soc,log_path,alpha,fake_ip,server_ip):
        print('init: accepting client')
        self.client,_ = soc.accept()
        self.target = None
        self.request_url = server_ip
        self.fake_ip = (fake_ip,0)
        self.send_count = 0 
        self.recv_count = 0
        self.a = alpha
        self.log = open(log_path,'w+')
    def getClientRequest(self):
        #print('receving from client')
        request = self.client.recv(4096)
        if request is None:
            return None
        return request

    def connectServer(self,request):
        self.target = socket(AF_INET, SOCK_STREAM)
        #print('connecting to server')
        self.target.bind(self.fake_ip)
        self.target.connect((self.request_url,8080))
        #print('sending message to server')
        self.target.send(request)
        self.blocking()

    def blocking(self):
        pat_big_buck = re.compile(b'bunny.f4m')
        pat_length = re.compile(b'Content-Length: .\w+')
        pat_response = re.compile(b'Connection:')
        pat_name = re.compile(b'/vod/.*Frag[0-9]*')
        inputs = [self.client, self.target]
        while True:
            readable, writeable, errs = select.select(inputs, [], inputs, 3)
            if errs:
                break
            for soc in readable:
                data = soc.recv(409600)
                if data:
                    if soc is self.client:
                        self.send_count += 1
                        ts = time.time()
                        result = re.search(pat_big_buck,data,flags=0)
                        if result != None:
                            data.decode()
                            data = data.replace('bunny','bunny_nolist')
                            data.encode()
                        result = re.search(pat_name,data)
                        if result != None:
                            chunkname = result.group(0)
                        else:
                            chunkname = 'Not a chunk'
                        self.target.send(data)
                    if soc is self.target:
                        result = re.search(pat_length,data,flags=0)
                        if result != None:
                            length = float(result.group(0)[16:])
                        result = re.search(pat_response,data,flags=0)
                        if result != None:
                            if self.recv_count > 0:
                                tf = time.time()
                                dur = tf-ts
                                thr = 8*length/(tf-ts)/1024
                                avg_thr = self.a * dur + (1-self.a) * t_old
                                t_old = dur
                                self.log.write('%d %f %d %d %s %s\n' % (tf,dur,thr,avg_thr,self.request_url,chunkname))
                            else:
                                t_old = 0
                            self.recv_count += 1
                        self.client.send(data)
                else:
                    break
        self.client.close()
        self.target.close()
        self.log.close()

    def run(self):
        request = self.getClientRequest()
        if request:
            self.connectServer(request)


if __name__ == '__main__':
    print(sys.argv)
    log_path = sys.argv[1]
    a = sys.argv[2]
    listen_port = sys.argv[3]
    fake_ip = sys.argv[4]
    server_ip = sys.argv[5]
    proxySocket = socket(AF_INET, SOCK_STREAM)
    proxySocket.bind(('', int(listen_port)))
    proxySocket.listen(1)
    print('The proxy is ready to receive')

    while True:
        try:
            thread.start_new_thread(Proxy(proxySocket,log_path,float(a),fake_ip, server_ip).run, ())
        except Exception as e:
            print(e)

